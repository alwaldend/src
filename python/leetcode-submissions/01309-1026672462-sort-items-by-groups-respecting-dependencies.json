{
    "id": 1026672462,
    "status_display": "Accepted",
    "lang": "python3",
    "question_id": 1309,
    "title_slug": "sort-items-by-groups-respecting-dependencies",
    "code": "class Solution:\n    def sortItems(self, n, m, group, beforeItems):\n        # If an item belongs to zero group, assign it a unique group id.\n        group_id = m\n        for i in range(n):\n            if group[i] == -1:\n                group[i] = group_id\n                group_id += 1\n        \n        # Sort all item regardless of group dependencies.\n        item_graph = [[] for _ in range(n)]\n        item_indegree = [0] * n\n        \n        # Sort all groups regardless of item dependencies.\n        group_graph = [[] for _ in range(group_id)]\n        group_indegree = [0] * group_id      \n        \n        for curr in range(n):\n            for prev in beforeItems[curr]:\n                # Each (prev -\u003e curr) represents an edge in the item graph.\n                item_graph[prev].append(curr)\n                item_indegree[curr] += 1\n                \n                # If they belong to different groups, add an edge in the group graph.\n                if group[curr] != group[prev]:\n                    group_graph[group[prev]].append(group[curr])\n                    group_indegree[group[curr]] += 1      \n        \n        # Tologlogical sort nodes in graph, return [] if a cycle exists.\n        def topologicalSort(graph, indegree):\n            visited = []\n            stack = [node for node in range(len(graph)) if indegree[node] == 0]\n            while stack:\n                cur = stack.pop()\n                visited.append(cur)\n                for neib in graph[cur]:\n                    indegree[neib] -= 1\n                    if indegree[neib] == 0:\n                        stack.append(neib)\n            return visited if len(visited) == len(graph) else []\n\n        item_order = topologicalSort(item_graph, item_indegree)\n        group_order = topologicalSort(group_graph, group_indegree)\n        \n        if not item_order or not group_order: \n            return []\n        \n        # Items are sorted regardless of groups, we need to \n        # differentiate them by the groups they belong to.\n        ordered_groups = collections.defaultdict(list)\n        for item in item_order:\n            ordered_groups[group[item]].append(item)\n        \n        # Concatenate sorted items in all sorted groups.\n        # [group 1, group 2, ... ] -\u003e [(item 1, item 2, ...), (item 1, item 2, ...), ...]\n        answer = []\n        for group_index in group_order:\n            answer += ordered_groups[group_index]\n        return answer",
    "title": "Sort Items by Groups Respecting Dependencies",
    "url": "/submissions/detail/1026672462/",
    "lang_name": "Python3",
    "time": "1 year, 8 months",
    "timestamp": 1692531281,
    "status": 10,
    "runtime": "352 ms",
    "is_pending": "Not Pending",
    "memory": "35.6 MB",
    "compare_result": "11111111111111111",
    "flag_type": 1
}